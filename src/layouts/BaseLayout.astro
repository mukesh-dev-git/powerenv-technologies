---
// Import the regular components
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';

// 1. Import the Vercel Analytics component for Astro
import Analytics from '@vercel/analytics/astro';

export interface Props {
	title: string;
	showLoader?: boolean;
}

const { title, showLoader = false } = Astro.props;
---
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content="Powerenv Technologies provides ultra-reliable smart metering to eliminate revenue loss and modernize India's grid." />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<title>{title} | Powerenv Technologies</title>

		<!-- Google Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Lato:wght@400;700&display=swap" rel="stylesheet">

		<!-- Global Stylesheet -->
		<link rel="stylesheet" href="/styles/global.css">
		
		<!-- Animation Enhancements -->
		<link rel="stylesheet" href="/styles/animations.css">
		
		<!-- Inline CSS Variables for Vercel compatibility -->
		<style>
			:root {
				--primary-blue: #0A2342;
				--secondary-green: #2CA58D;
				--neutral-light-gray: #F4F6F8;
				--neutral-dark-gray: #333333;
				--text-light: #FFFFFF;
				--font-heading: 'Montserrat', sans-serif;
				--font-body: 'Lato', sans-serif;
			}
			
			/* CRITICAL: Force scrollable content - override all animations.css styles */
			html, html.has-scroll-smooth {
				overflow: auto !important;
				height: auto !important;
			}
			
			body, .has-scroll-smooth body {
				overflow: auto !important;
				overflow-x: hidden !important;
				position: static !important;
				height: auto !important;
			}
			
			/* Override any locomotive scroll styles completely */
			[data-scroll-container], 
			.has-scroll-smooth [data-scroll-container],
			.locomotive-initialized [data-scroll-container] {
				height: auto !important;
				overflow: visible !important;
				min-height: auto !important;
			}
			
			.main-container {
				position: relative;
				z-index: 1;
				min-height: 100vh;
				height: auto !important;
				overflow: visible !important;
			}
			
			/* Ensure main content has proper height */
			main {
				min-height: auto !important;
				position: relative;
				z-index: 1;
				height: auto !important;
				overflow: visible !important;
			}

			/* Force sections to be visible */
			section {
				display: block !important;
				position: relative !important;
				overflow: visible !important;
				height: auto !important;
			}
		</style>
	</head>
	<body>
		<div class="main-container">
			<Header />
			<main>
				<slot /> <!-- Page content will be injected here -->
			</main>
			<Footer />
		</div>

		<!-- AOS (Animate On Scroll) Library - Using CDN with proper loading -->
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.css" />
		
		<!-- Enhanced Animation Implementation -->
		<script type="module">
			// Force remove any locomotive scroll classes and ensure scrolling
			const forceScrollingEnabled = () => {
				// Remove problematic classes from html and body
				document.documentElement.classList.remove('has-scroll-smooth', 'has-scroll-dragging', 'locomotive-initialized');
				document.body.classList.remove('has-scroll-smooth', 'locomotive-initialized');
				
				// Force scrollable styles
				document.documentElement.style.overflow = 'auto';
				document.body.style.overflow = 'auto';
				document.body.style.overflowX = 'hidden';
				document.body.style.height = 'auto';
				document.body.style.position = 'static';

				// Find and fix any data-scroll-container elements
				const scrollContainer = document.querySelector('[data-scroll-container]');
				if (scrollContainer) {
					scrollContainer.style.height = 'auto';
					scrollContainer.style.overflow = 'visible';
					scrollContainer.style.minHeight = 'auto';
				}
			};

			// Load AOS library dynamically
			const loadAOS = () => {
				return new Promise((resolve, reject) => {
					const script = document.createElement('script');
					script.src = 'https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.js';
					script.onload = () => resolve();
					script.onerror = () => reject();
					document.head.appendChild(script);
				});
			};

			// Initialize AOS animations
			const initializeAOSAnimations = async () => {
				try {
					await loadAOS();
					
					// Wait a bit for AOS to be available
					await new Promise(resolve => setTimeout(resolve, 100));
					
					if (typeof AOS !== 'undefined') {
						AOS.init({
							duration: 1000,          // Animation duration
							easing: 'ease-out-cubic', // Easing function
							once: true,              // Animation happens only once
							offset: 100,             // Trigger point
							delay: 0,                // Global delay
							disable: false           // Always enabled
						});
						console.log('AOS animations initialized successfully');
						return true;
					} else {
						throw new Error('AOS not available');
					}
				} catch (error) {
					console.log('Using fallback animations (AOS not available)');
					initializeFallbackAnimations();
					return false;
				}
			};

			// Enhanced fallback animations
			const initializeFallbackAnimations = () => {
				// Create intersection observer for smooth animations
				const observerOptions = {
					threshold: 0.1,
					rootMargin: '0px 0px -50px 0px'
				};

				const observer = new IntersectionObserver((entries) => {
					entries.forEach(entry => {
						if (entry.isIntersecting) {
							const element = entry.target;
							element.style.opacity = '1';
							element.style.transform = 'translateY(0) scale(1)';
							element.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
							observer.unobserve(element);
						}
					});
				}, observerOptions);

				// Observe elements with data-aos attributes
				document.querySelectorAll('[data-aos]').forEach(el => {
					el.style.opacity = '0';
					el.style.transform = 'translateY(30px) scale(0.95)';
					observer.observe(el);
				});

				// Hero elements with staggered animation
				const heroElements = [
					{ el: document.querySelector('.hero h1'), delay: 200 },
					{ el: document.querySelector('.hero .sub-headline'), delay: 400 },
					{ el: document.querySelector('.hero .button-primary'), delay: 600 }
				];
				
				heroElements.forEach(({ el, delay }) => {
					if (el) {
						setTimeout(() => {
							el.style.opacity = '1';
							el.style.transform = 'translateY(0) scale(1)';
							el.style.transition = 'all 1s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
						}, delay);
					}
				});

				console.log('Enhanced fallback animations initialized');
			};

			// Initialize everything
			const initialize = () => {
				// First, force scrolling to be enabled
				forceScrollingEnabled();
				
				// Then initialize animations
				setTimeout(initializeAOSAnimations, 200);
			};

			// Initialize immediately and set up observers
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initialize);
			} else {
				initialize();
			}

			// Also run after page load as fallback
			window.addEventListener('load', () => {
				forceScrollingEnabled();
				// Refresh AOS in case elements were added
				if (typeof AOS !== 'undefined' && AOS.refresh) {
					AOS.refresh();
				}
			});
			
			// Periodically check and fix scrolling (reduce frequency)
			setInterval(forceScrollingEnabled, 5000);
		</script>

		<!-- 2. Add the Analytics component here -->
		<Analytics />
	</body>
</html>
